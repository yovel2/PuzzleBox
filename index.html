<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>驻 5 拽 - 专住 住驻转</title>
    <style>
        :root {
            --aspect-ratio: 1200 / 1080;
            --puzzle-max-width: 450px;
            --win-color: #28a745;
        }

        body {
            font-family: system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f2f5;
            margin: 0;
            padding: 10px;
            overflow-x: hidden;
            touch-action: none; /* 拽专 专专 拽  */
        }

        h1 { font-size: 1.2rem; margin: 10px 0; color: #333; }

        /*  驻 */
        #puzzle-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            width: 90vw;
            max-width: var(--puzzle-max-width);
            aspect-ratio: var(--aspect-ratio);
            background: #fff;
            border: 4px solid #333;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            position: relative;
            transition: all 0.5s ease;
        }

        /* 住 专拽 */
        .slot {
            width: 100%;
            height: 100%;
            border-left: 1px dashed #ccc;
            position: relative;
            box-sizing: border-box;
        }
        .slot:last-child { border-left: none; }

        /* 拽 注爪 */
        .piece {
            width: 100%;
            height: 100%;
            cursor: grab;
            background-size: 500% 100%;
            box-sizing: border-box;
            border: 1px solid rgba(0,0,0,0.15); /* 住专转 拽 砖拽砖转 */
            touch-action: none;
            user-select: none;
            position: relative;
            transition: border 0.3s ease;
        }

        /* 爪 专专 */
        .piece.dragging {
            opacity: 0.9;
            z-index: 1000 !important;
            position: fixed;
            pointer-events: none;
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            border: 2px solid #007bff;
        }

        /* 拽 拽 */
        #pieces-bank {
            display: flex;
            gap: 8px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 12px;
            width: 90vw;
            max-width: var(--puzzle-max-width);
            min-height: 110px;
            justify-content: center;
        }

        /* 砖专 注   砖 拽 拽 */
        .piece-wrapper {
            width: calc((90vw / 5) - 10px);
            max-width: calc(var(--puzzle-max-width) / 5 - 10px);
            aspect-ratio: var(--aspect-ratio);
            flex-shrink: 0;
        }

        /* --- 爪 爪 --- */
        #puzzle-container.win-state {
            border-color: var(--win-color);
            box-shadow: 0 0 40px rgba(40, 167, 69, 0.5);
        }

        /* 住专转 住专转 爪 */
        .win-state .piece {
            border: none !important;
        }
        .win-state .slot {
            border: none !important;
        }

        #message {
            display: none;
            background: var(--win-color);
            color: white;
            padding: 12px 30px;
            border-radius: 50px;
            margin-bottom: 15px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            animation: pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes pop { from { transform: scale(0.5); } to { transform: scale(1); } }

        button {
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            border-radius: 8px;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .confetti {
            position: fixed; width: 8px; height: 8px; z-index: 999; top: -10px;
            animation: fall linear forwards;
        }
        @keyframes fall { to { transform: translateY(110vh) rotate(720deg); } }
    </style>
</head>
<body>

    <h1>专 转 驻</h1>
    <div id="message">转 砖 爪! </div>
    
    <div id="puzzle-container">
        <div class="slot" data-index="0"></div>
        <div class="slot" data-index="1"></div>
        <div class="slot" data-index="2"></div>
        <div class="slot" data-index="3"></div>
        <div class="slot" data-index="4"></div>
    </div>

    <button onclick="location.reload()">砖拽 砖</button>

    <div id="pieces-bank"></div>

    <script>
        const imageUrl = 'homePaint.png'; 
        const container = document.getElementById('puzzle-container');
        const bank = document.getElementById('pieces-bank');
        const slots = document.querySelectorAll('.slot');
        const msg = document.getElementById('message');

        let activePiece = null;
        let startX, startY, origX, origY;

        function init() {
            const indices = [0, 1, 2, 3, 4];
            const pieces = indices.map(i => {
                const wrapper = document.createElement('div');
                wrapper.className = 'piece-wrapper';
                
                const p = document.createElement('div');
                p.className = 'piece';
                p.style.backgroundImage = `url('${imageUrl}')`;
                p.style.backgroundPosition = `${i * 25}% 0%`; 
                p.dataset.idx = i;

                p.addEventListener('mousedown', startDrag);
                p.addEventListener('touchstart', startDrag, {passive: false});

                wrapper.appendChild(p);
                return wrapper;
            });

            pieces.sort(() => Math.random() - 0.5).forEach(w => bank.appendChild(w));
        }

        function startDrag(e) {
            e.preventDefault();
            activePiece = e.target;
            const touch = e.type === 'touchstart' ? e.touches[0] : e;
            
            const rect = activePiece.getBoundingClientRect();
            startX = touch.clientX;
            startY = touch.clientY;
            origX = rect.left;
            origY = rect.top;

            activePiece.style.width = rect.width + 'px';
            activePiece.style.height = rect.height + 'px';
            activePiece.classList.add('dragging');
            activePiece.style.left = origX + 'px';
            activePiece.style.top = origY + 'px';

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, {passive: false});
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
        }

        function drag(e) {
            if (!activePiece) return;
            const touch = e.type === 'touchmove' ? e.touches[0] : e;
            const dx = touch.clientX - startX;
            const dy = touch.clientY - startY;

            activePiece.style.left = (origX + dx) + 'px';
            activePiece.style.top = (origY + dy) + 'px';
        }

        function endDrag(e) {
            if (!activePiece) return;
            const touch = e.type === 'touchend' ? e.changedTouches[0] : e;
            activePiece.classList.remove('dragging');
            
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetSlot = elementBelow ? elementBelow.closest('.slot') : null;
            const targetBank = elementBelow ? elementBelow.closest('#pieces-bank') : null;

            if (targetSlot) {
                if (targetSlot.children.length > 0) {
                    const existingPiece = targetSlot.children[0];
                    const currentParent = activePiece.parentElement;
                    targetSlot.appendChild(activePiece);
                    currentParent.appendChild(existingPiece);
                } else {
                    targetSlot.appendChild(activePiece);
                }
            } else if (targetBank || !targetSlot) {
                // 专 拽 驻 拽    注 住
                const emptyWrapper = Array.from(bank.children).find(w => w.children.length === 0);
                if (emptyWrapper) emptyWrapper.appendChild(activePiece);
            }

            activePiece.style.width = '';
            activePiece.style.height = '';
            activePiece.style.left = '';
            activePiece.style.top = '';
            activePiece = null;

            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchend', endDrag);
            
            checkWin();
        }

        function checkWin() {
            let winCount = 0;
            slots.forEach(s => {
                const p = s.children[0];
                if (p && p.dataset.idx === s.dataset.index) winCount++;
            });

            if (winCount === 5) {
                msg.style.display = 'block';
                container.classList.add('win-state');
                for (let i = 0; i < 100; i++) setTimeout(createConfetti, i * 20);
            }
        }

        function createConfetti() {
            const colors = ['#ff0', '#f0f', '#0ff', '#0f0', '#fff'];
            const c = document.createElement('div');
            c.className = 'confetti';
            c.style.left = Math.random() * 100 + 'vw';
            c.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            c.style.width = (Math.random() * 8 + 4) + 'px';
            c.style.height = c.style.width;
            c.style.animationDuration = (Math.random() * 2 + 2) + 's';
            document.body.appendChild(c);
            setTimeout(() => c.remove(), 4000);
        }

        init();
    </script>
</body>
</html>